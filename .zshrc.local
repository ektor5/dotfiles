#Ek5

export PATH=$PATH:~/.gem/ruby/2.2.0/bin

bindkey -v
bindkey "^\[\." insert-last-word

# my hosts file includes tons of spam hosts, disable completion
zstyle ':completion:*:hosts' hosts 

export EDITOR=vim

## ALIAS
alias g="git status"
alias dm="dmesg"
alias pigo="ping www.google.it"
alias y="yaourt"
alias v="vim"
alias sshp="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
alias scpp="scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

## git archive

gitorig () {
# VER 

  local VER="${1:-}"
  local ORIG=`basename $(git remote show -n origin | grep Fetch | cut -d: -f2-)`
  local -l NAME="${2:-$ORIG}"
  local BR=${3:-HEAD}
  (( $? )) && exit 1

  local OUTPUT="../${NAME}_${VER}.orig.tar.gz"
  local PREF="${NAME}-${VER}"

  git archive --format=tar.gz -o "$OUTPUT" --prefix="$PREF/" "$BR"

}

scm_ver()
{
  ## from kernel sources
	local short
	short=false

	if test "$1" = "--short"; then
		short=true
	fi

	# Check for git and a git repo.
	if test -z "$(git rev-parse --show-cdup 2>/dev/null)" &&
	   head=`git rev-parse --verify --short HEAD 2>/dev/null`; then

		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
		# it, because this version is defined in the top level Makefile.
		if [ -z "`git describe --exact-match 2>/dev/null`" ]; then

			# If only the short version is requested, don't bother
			# running further git commands
			if $short; then
				echo "+"
				return
			fi
			# If we are past a tagged commit (like
			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
			if atag="`git describe 2>/dev/null`"; then
				#echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'
        #edited by ek5 -> 1.6.6-00001-g0bc4b15%
        awk -F- '{printf("%s+%05d+%s", $(NF-2), $(NF-1),$(NF))}' <<< "$atag"
        
			# If we don't have a tag at all we print -g{commitish}.
			else
				printf '%s%s' -g $head
			fi

    else
      #we do not have Makefiles lol
      printf '%s' "`git describe 2>/dev/null`" 
		fi

		# Is this git on svn?
		if git config --get svn-remote.svn.url >/dev/null; then
			printf -- '-svn%s' "`git svn find-rev $head`"
		fi

		# Check for uncommitted changes
		if git diff-index --name-only HEAD | grep -qv "^debian/"; then
			printf '%s' -dirty
		fi

		# All done with git
		return
	fi
}

gitorigver() {
  #takes ver from commit, kernel style
  VER=`scm_ver`
  gitorig "$VER" $@
}


#pb
pb () { 
  curl -F "c=@${1:--}" https://ptpb.pw/${2} 
}

pbx () { 
  curl -sF "c=@${1:--}" -w "%{redirect_url}" 'https://ptpb.pw/?r=1' \
    -o /dev/stderr | xsel -l /dev/null -b 
}

pbs () {
  gm import -window ${1:-root} /tmp/$$.png
  pbx /tmp/$$.png
}

#Termite 
if [[ $TERM == xterm-termite ]]; then
  . /etc/profile.d/vte.sh
  __vte_osc7
fi

#ranger
rg() {
  if [ -z "$RANGER_LEVEL" ]
  then
    ranger
  else
    exit
  fi
}   

# Compatible with ranger 1.4.2 through 1.7.*
#
# Automatically change the directory in bash after closing ranger
#
# This is a bash function for .bashrc to automatically change the directory to
# the last visited one after ranger quits.
# To undo the effect of this function, you can type "cd -" to return to the
# original directory.

function ranger-cd {
    tempfile="$(mktemp)"
    /usr/bin/ranger --choosedir="$tempfile" "${@:-$(pwd)}"
    test -f "$tempfile" &&
    if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
        cd -- "$(cat "$tempfile")"
    fi
    rm -f -- "$tempfile"
}

function ranger-cd-show() { BUFFER="ranger-cd"; zle accept-line; }

zle -N ranger-cd-show

# This binds Ctrl-O to ranger-cd:
bindkey "\C-o" ranger-cd-show

# function zle-line-init zle-keymap-select {
#   VIM_PROMPT="%{$fg_bold[yellow]%} [% NORMAL]% %{$reset_color%}"
#   RPS1="${${KEYMAP/vicmd/$VIM_PROMPT}/(main|viins)/} $(git_custom_status) $EPS1"
#   zle reset-prompt
# }
# zle -N zle-line-init
# zle -N zle-keymap-select

